pragma solidity ^0.4.21;
import "./CacaoLibrary.sol";
import "./SafeMath.sol";
import "./IVerifySignature.sol";

/// @title Abstract contract that controls the creation of Cacaos
/// @author Guillermo Hernandez (0w3w)
/// @notice 5 creation addresses, the contract needs a majority of votes from this addresses in order to create Cacaos. (A multisignature process)
/// The creation addresses are unique to the contract and can be replaced by a vote from the majority.
contract CacaoCreation is IVerifySignature {
    using CacaoLibrary for uint256;
    using SafeMath for uint256;

    // The created cacaos go to the "Limbo", an intermediate state between creation and distribution.
    uint256 public cacaosInLimbo = 0;

    /// @notice Creates coins
    /// @dev Needs a _creationMajority of signatures
    /// @param _amount The amount of coins to issue
    /// @param _nonce Random nonce generated by client
    /// @param _address1 The 1st creation address that signed the transaction.
    /// @param _signature1 The signature of the transaction signed by `_address1`
    /// @param _address2 The 2nd creation address that signed the transaction.
    /// @param _signature2 The signature of the transaction signed by `_address2`
    /// @param _address3 The 3rd creation address that signed the transaction.
    /// @param _signature3 The signature of the transaction signed by `_address3`
    function create(
        uint256 _amount,
        bytes32 _nonce,
        address _address1,
        bytes _signature1,
        address _address2,
        bytes _signature2,
        address _address3,
        bytes _signature3) external {
        _amount.requireValidAmount();
        require(_address1 != _address2, "Creator addresses must be different");
        require(_address2 != _address3, "Creator addresses must be different");
        assertCreationAddress(_amount, _nonce, _address1, _signature1);
        assertCreationAddress(_amount, _nonce, _address2, _signature2);
        assertCreationAddress(_amount, _nonce, _address3, _signature3);
        cacaosInLimbo = cacaosInLimbo.add(_amount);
        emit Created(_amount);
    }

    /// @notice Creates a Hash of the coin creation data.
    /// @dev This is used to sign the data without needing a transaction, without any gas cost and without confirmation delay.
    /// @param _amount The amount of coins to issue
    /// @param _nonce Random nonce generated by client
    /// @return The hash of the transaction calculated using by `msg.sender`
    function hashCreateData(uint256 _amount, bytes32 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_amount, _nonce));
    }

    /// @notice Decreases the amount from the available in the limbo.
    /// @dev Function that will be called by the distribution contract.
    /// @param _amount The amount of cacaos to Issue.
    function draw(uint256 _amount) internal {
        _amount.requireValidAmount();
        require(cacaosInLimbo >= _amount, "Not enough coins to draw, create more coins.");
        cacaosInLimbo = cacaosInLimbo.sub(_amount);
    }

    /// @notice Whether the _address can create cacaos or not
    /// @dev Abstract Method
    /// @param _address The address to verify
    /// @return True if it can
    function canCreate(address _address) internal returns (bool _isValid);

    /// @notice Assert the _signature of the create transaction data for a given _address
    /// @param _amount The amount of coins to issue
    /// @param _nonce Random nonce generated by _address
    /// @param _address The creation address that signed the transaction
    /// @param _signature The signature of the transaction signed by `_address`
    function assertCreationAddress(uint256 _amount, bytes32 _nonce, address _address, bytes _signature) private {
        require(canCreate(_address), "Invalid creation address");
        bytes32 txHash = hashCreateData(_amount, _nonce);
        verify(txHash, _signature, _address);
    }

    /// @notice Triggers when cacaos are created.
    /// @param _amount The amount of created cacaos.
    event Created(uint256 _amount);
}
