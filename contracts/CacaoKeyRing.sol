pragma solidity ^0.4.21;
import "./ECRecovery.sol";
import "./IVerifySignature.sol";

/// @title Stores contract relevant addresses information
/// @author Guillermo Hernandez (0w3w)
contract CacaoKeyRing is IVerifySignature {

    // Structure that will save whether an address is a valid creation address or not, and if the key has been revoked or not.
    struct AddressMetadata {
        bool isCreation;
        bool isDistribution;
        bool isValid;
    }

    // Stores the mapping between creator addresses and AddressMetadata
    mapping (address => AddressMetadata) private _keyring;

    /// @notice Methods decorated with this will only be able to be executed by a creator address.
    modifier onlyCreator() {
        require(isCreator(msg.sender), "Only creator senders can execute.");
        _;
    }

    /// @notice Methods decorated with this will only be able to be executed by a distributor address.
    modifier onlyDistributor() {
        require(isDistributor(msg.sender), "Only distributor senders can execute.");
        _;
    }

	/// @notice Initialize the contract by registering the creation and distribution addresses.
    /// @param _creatorAddress1 The creator address #1
    /// @param _creatorAddress2 The creator address #2
    /// @param _creatorAddress3 The creator address #3
    /// @param _creatorAddress4 The creator address #4
    /// @param _creatorAddress5 The creator address #5
    /// @param _distributionAddress1 The distributor address #1
    /// @param _distributionAddress2 The distributor address #2
    /// @param _distributionAddress3 The distributor address #3
    constructor (
        address _creatorAddress1,
        address _creatorAddress2,
        address _creatorAddress3,
        address _creatorAddress4,
        address _creatorAddress5,
        address _distributionAddress1,
        address _distributionAddress2,
        address _distributionAddress3
    ) internal {
        setCreatorAddress(_creatorAddress1);
        setCreatorAddress(_creatorAddress2);
        setCreatorAddress(_creatorAddress3);
        setCreatorAddress(_creatorAddress4);
        setCreatorAddress(_creatorAddress5);
        setDistributionAddress(_distributionAddress1);
        setDistributionAddress(_distributionAddress2);
        setDistributionAddress(_distributionAddress3);
    }

    /// @notice Whether the _address is a creator address or not
    /// @param _address The address to verify
    /// @return True if the _address is a creator address
    function isCreator(address _address) public view returns (bool result) {
        AddressMetadata memory _addressMetadata = _keyring[_address];
        return _addressMetadata.isCreation && _addressMetadata.isValid;
    }

    /// @notice Whether the _address is a distributor address or not
    /// @param _address The address to verify
    /// @return True if the _address is a distributor address
    function isDistributor(address _address) public view returns (bool result) {
        AddressMetadata memory _addressMetadata = _keyring[_address];
        return _addressMetadata.isDistribution && _addressMetadata.isValid;
    }

    /// @notice Sets a creator address
    /// @dev Fails if the address is already a creator
    function setCreatorAddress(address _address) private {
        AddressMetadata storage _addressMetadata = _keyring[_address];
        assert(_address != address(0));
        require(!_addressMetadata.isCreation && !_addressMetadata.isValid, "Creator address already in use or invalidated");
        _addressMetadata.isCreation = true;
        _addressMetadata.isDistribution = false;
        _addressMetadata.isValid = true;
    }

    /// @notice Sets a distributor address
    /// @dev Fails if the address is already a distributor address
    function setDistributionAddress(address _address) private {
        assert(_address != address(0));
        require(!_keyring[_address].isDistribution && !_keyring[_address].isValid, "Distribution address already in use or invalidated");
        _keyring[_address].isCreation = false;
        _keyring[_address].isDistribution = true;
        _keyring[_address].isValid = true;
    }

    /*
        SECURITY
        - Creator and Distribution address replacement.
        Some multisignature concepts from https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs
    */

    /// @notice Replaces a creation address
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @param _address1 The 1st creation address that signed the transaction.
    /// @param _signature1 The signature of the transaction signed by `_address1`
    /// @param _address2 The 2nd creation address that signed the transaction.
    /// @param _signature2 The signature of the transaction signed by `_address2`
    /// @param _address3 The 3rd creation address that signed the transaction.
    /// @param _signature3 The signature of the transaction signed by `_address3`
    function replaceCreationAddress(
        address _oldAddress,
        address _newAddress,
        bytes32 _nonce,
        address _address1,
        bytes _signature1,
        address _address2,
        bytes _signature2,
        address _address3,
        bytes _signature3) external {
        // Verify old address validity
        AddressMetadata storage _oldMetadata = _keyring[_oldAddress];
        require(_oldMetadata.isValid, "The old address is not a valid address to replace.");
        require(_oldMetadata.isCreation, "The old address is not a valid creation address.");
        // Verify signatures
        require(_address1 != _address2, "Signing addresses must be different");
        require(_address2 != _address3, "Signing addresses must be different");
        require(isCreator(_address1), "Invalid creation _address1 address");
        require(isCreator(_address2), "Invalid creation _address2 address");
        require(isCreator(_address3), "Invalid creation _address3 address");
        bytes32 txHash = hashReplaceData(_oldAddress, _newAddress, _nonce);
        verify(txHash, _signature1, _address1);
        verify(txHash, _signature2, _address2);
        verify(txHash, _signature3, _address3);
        // Replace Creation Address
        _oldMetadata.isValid = false;
        setCreatorAddress(_newAddress);
        emit Replaced(_oldAddress, _newAddress);
    }

    /// @notice Replaces a distribution address
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @param _address1 The 1st creation address that signed the transaction.
    /// @param _signature1 The signature of the transaction signed by `_address1`
    /// @param _address2 The 2nd creation address that signed the transaction.
    /// @param _signature2 The signature of the transaction signed by `_address2`
    function replaceDistributionAddress(
        address _oldAddress,
        address _newAddress,
        bytes32 _nonce,
        address _address1,
        bytes _signature1,
        address _address2,
        bytes _signature2) external {
        // Verify old address validity
        AddressMetadata storage _oldMetadata = _keyring[_oldAddress];
        require(_oldMetadata.isValid, "The old address is not a valid address to replace.");
        require(_oldMetadata.isDistribution, "The old address is not a valid distribution address.");
        // Verify signatures
        require(_address1 != _address2, "Signing addresses must be different");
        require(isDistributor(_address1), "Invalid distributor _address1 address");
        require(isDistributor(_address2), "Invalid distributor _address2 address");
        bytes32 txHash = hashReplaceData(_oldAddress, _newAddress, _nonce);
        verify(txHash, _signature1, _address1);
        verify(txHash, _signature2, _address2);
        // Replace Creation Address
        _oldMetadata.isValid = false;
        setDistributionAddress(_newAddress);
        emit Replaced(_oldAddress, _newAddress);
    }

    /// @notice Creates a Hash of address replacement data.
    /// @dev This is used to sign the data without needing a transaction, without any gas cost and without confirmation delay.
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @return The hash of the transaction calculated using by `msg.sender`
    function hashReplaceData(address _oldAddress, address _newAddress, bytes32 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_oldAddress, _newAddress, _nonce));
    }

/*
    /// @notice Batch replacement of the distribution addresses.
    function replaceDistributionAddresses(
        address[] _oldAddresses,
        address[] _newAddresses,
        bytes32 _nonce,
        address[] _creationAddresses,
        bytes _signature1,
        bytes _signature2,
        bytes _signature3)
    external {
        require(_oldAddresses.length == 3, "There should be exactly 3 _oldAddresses");
        require(_newAddresses.length == 3, "There should be exactly 3 _newAddresses");
        // Verify old addresses validity
        verifyOldAddressValidity(_oldAddresses, false);
        // Verify signatures
        bytes32 txHash = hashBatchReplaceData(_oldAddresses, _newAddresses, _nonce);
        verifyBatchReplacementSignatures(txHash, _creationAddresses, _signature1, _signature2, _signature3);
        // Invalidate old addresses
        _keyring[_oldAddresses[0]].isValid = false;
        _keyring[_oldAddresses[1]].isValid = false;
        _keyring[_oldAddresses[2]].isValid = false;
        // Set new addresses
        setDistributionAddress(_newAddresses[0]);
        setDistributionAddress(_newAddresses[1]);
        setDistributionAddress(_newAddresses[2]);
        emit Replaced(_oldAddresses[0], _newAddresses[0]);
        emit Replaced(_oldAddresses[1], _newAddresses[1]);
        emit Replaced(_oldAddresses[2], _newAddresses[2]);
    }

    /// @notice Creates a Hash of address batch replacement data.
    /// @dev This is used to sign the data without needing a transaction, without any gas cost and without confirmation delay.
    /// @param _oldAddresses The addresses to be replaced
    /// @param _newAddresses The new addresses
    /// @param _nonce Random nonce generated by client
    /// @return The hash of the transaction calculated using by `msg.sender`
    function hashBatchReplaceData(
        address[] _oldAddresses,
        address[] _newAddresses,
        bytes32 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_oldAddresses, _newAddresses, _nonce));
    }

    function verifyBatchReplacementSignatures (
        bytes32 txHash,
        address[] _creationAddresses,
        bytes _signature1,
        bytes _signature2,
        bytes _signature3 ) private {
        require(_creationAddresses.length == 3, "There should be exactly 3 signing addresses");
        require(_creationAddresses[0] != _creationAddresses[1], "Signing addresses must be different");
        require(_creationAddresses[1] != _creationAddresses[2], "Signing addresses must be different");
        require(isCreator(_creationAddresses[0]), "Invalid [0] creation address");
        require(isCreator(_creationAddresses[1]), "Invalid [1] creation address");
        require(isCreator(_creationAddresses[2]), "Invalid [2] creation address");
        verify(txHash, _signature1, _creationAddresses[0]);
        verify(txHash, _signature2, _creationAddresses[1]);
        verify(txHash, _signature3, _creationAddresses[2]);
    }

    function verifyOldAddressValidity(address[] _oldAddresses, bool isCreation) private view {
        for (uint i = 0; i < _oldAddresses.length; i++) {
            AddressMetadata storage _oldMetadata = _keyring[_oldAddresses[i]];
            require(_oldMetadata.isValid, "address is not a valid address to replace.");
            if (isCreation) {
                require(_oldMetadata.isCreation, "address is not a valid creation address.");
            } else {
                require(_oldMetadata.isDistribution, "address is not a valid distribution address.");
            }
        }
    }
*/

    /// @notice Triggers when an address is replaced.
    event Replaced(address _originalAddress, address _newAddress);
}