pragma solidity ^0.4.21;
import "./ECRecovery.sol";
import "./IVerifySignature.sol";

/// @title Stores contract relevant addresses information
/// @author Guillermo Hernandez (0w3w)
contract CacaoKeyRing is IVerifySignature {

    // Structure that will save whether an address is a valid creation address or not, and if the key has been revoked or not.
    struct AddressMetadata {
        bool isCreation;
        bool isDistribution;
        bool isValid;
    }

    // Stores the mapping between creator addresses and AddressMetadata
    mapping (address => AddressMetadata) private _keyring;

    /// @notice Methods decorated with this will only be able to be executed by a creator address.
    modifier onlyCreator() {
        require(isCreator(msg.sender), "Only creator senders can execute.");
        _;
    }

    /// @notice Methods decorated with this will only be able to be executed by a distributor address.
    modifier onlyDistributor() {
        require(isDistributor(msg.sender), "Only distributor senders can execute.");
        _;
    }

	/// @notice Initialize the contract by registering the creation and distribution addresses.
    /// @param _creatorAddress1 The creator address #1
    /// @param _creatorAddress2 The creator address #2
    /// @param _creatorAddress3 The creator address #3
    /// @param _creatorAddress4 The creator address #4
    /// @param _creatorAddress5 The creator address #5
    /// @param _distributionAddress1 The distributor address #1
    /// @param _distributionAddress2 The distributor address #2
    /// @param _distributionAddress3 The distributor address #3
    constructor (
        address _creatorAddress1,
        address _creatorAddress2,
        address _creatorAddress3,
        address _creatorAddress4,
        address _creatorAddress5,
        address _distributionAddress1,
        address _distributionAddress2,
        address _distributionAddress3
    ) internal {
        setCreatorAddress(_creatorAddress1);
        setCreatorAddress(_creatorAddress2);
        setCreatorAddress(_creatorAddress3);
        setCreatorAddress(_creatorAddress4);
        setCreatorAddress(_creatorAddress5);
        setDistributionAddress(_distributionAddress1);
        setDistributionAddress(_distributionAddress2);
        setDistributionAddress(_distributionAddress3);
    }

    /// @notice Whether the _address is a creator address or not
    /// @param _address The address to verify
    /// @return True if the _address is a creator address
    function isCreator(address _address) public view returns (bool result) {
        AddressMetadata memory _addressMetadata = _keyring[_address];
        return _addressMetadata.isCreation && _addressMetadata.isValid;
    }

    /// @notice Whether the _address is a distributor address or not
    /// @param _address The address to verify
    /// @return True if the _address is a distributor address
    function isDistributor(address _address) public view returns (bool result) {
        AddressMetadata memory _addressMetadata = _keyring[_address];
        return _addressMetadata.isDistribution && _addressMetadata.isValid;
    }

    /// @notice Sets a creator address
    /// @dev Fails if the address is already a creator
    function setCreatorAddress(address _address) private {
        AddressMetadata storage _addressMetadata = _keyring[_address];
        assert(_address != address(0));
        require(!_addressMetadata.isCreation && !_addressMetadata.isValid, "Creator address already in use or invalidated");
        _addressMetadata.isCreation = true;
        _addressMetadata.isDistribution = false;
        _addressMetadata.isValid = true;
    }

    /// @notice Sets a distributor address
    /// @dev Fails if the address is already a distributor address
    function setDistributionAddress(address _address) private {
        assert(_address != address(0));
        require(!_keyring[_address].isDistribution && !_keyring[_address].isValid, "Distribution address already in use or invalidated");
        _keyring[_address].isCreation = false;
        _keyring[_address].isDistribution = true;
        _keyring[_address].isValid = true;
    }

    /*
        SECURITY
        - Creator and Distribution address replacement.
        Some multisignature concepts from https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs
    */

    /// @notice Replaces a creation address
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @param _address1 The 1st creation address that signed the transaction.
    /// @param _signature1 The signature of the transaction signed by `_address1`
    /// @param _address2 The 2nd creation address that signed the transaction.
    /// @param _signature2 The signature of the transaction signed by `_address2`
    /// @param _address3 The 3rd creation address that signed the transaction.
    /// @param _signature3 The signature of the transaction signed by `_address3`
    function replaceCreationAddress(
        address _oldAddress,
        address _newAddress,
        bytes32 _nonce,
        address _address1,
        bytes _signature1,
        address _address2,
        bytes _signature2,
        address _address3,
        bytes _signature3) external {
        // Verify old address validity
        AddressMetadata storage _oldMetadata = _keyring[_oldAddress];
        require(_oldMetadata.isValid, "The old address is not a valid address to replace.");
        require(_oldMetadata.isCreation, "The old address is not a valid creation address.");
        // Verify signatures
        require(_address1 != _address2, "Signing addresses must be different");
        require(_address2 != _address3, "Signing addresses must be different");
        require(isCreator(_address1), "Invalid creation _address1 address");
        require(isCreator(_address2), "Invalid creation _address2 address");
        require(isCreator(_address3), "Invalid creation _address3 address");
        bytes32 txHash = hashReplaceData(_oldAddress, _newAddress, _nonce);
        verifyNonce(_nonce);
        verify(txHash, _signature1, _address1);
        verify(txHash, _signature2, _address2);
        verify(txHash, _signature3, _address3);
        // Replace Creation Address
        _oldMetadata.isValid = false;
        setCreatorAddress(_newAddress);
        emit Replaced(_oldAddress, _newAddress);
    }

    /// @notice Replaces a distribution address
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @param _address1 The 1st creation address that signed the transaction.
    /// @param _signature1 The signature of the transaction signed by `_address1`
    /// @param _address2 The 2nd creation address that signed the transaction.
    /// @param _signature2 The signature of the transaction signed by `_address2`
    function replaceDistributionAddress(
        address _oldAddress,
        address _newAddress,
        bytes32 _nonce,
        address _address1,
        bytes _signature1,
        address _address2,
        bytes _signature2) external {
        // Verify old address validity
        AddressMetadata storage _oldMetadata = _keyring[_oldAddress];
        require(_oldMetadata.isValid, "The old address is not a valid address to replace.");
        require(_oldMetadata.isDistribution, "The old address is not a valid distribution address.");
        // Verify signatures
        require(_address1 != _address2, "Signing addresses must be different");
        require(isDistributor(_address1), "Invalid distributor _address1 address");
        require(isDistributor(_address2), "Invalid distributor _address2 address");
        bytes32 txHash = hashReplaceData(_oldAddress, _newAddress, _nonce);
        verifyNonce(_nonce);
        verify(txHash, _signature1, _address1);
        verify(txHash, _signature2, _address2);
        // Replace Creation Address
        _oldMetadata.isValid = false;
        setDistributionAddress(_newAddress);
        emit Replaced(_oldAddress, _newAddress);
    }

    /// @notice Creates a Hash of address replacement data.
    /// @dev This is used to sign the data without needing a transaction, without any gas cost and without confirmation delay.
    /// @param _oldAddress The address to be replaced
    /// @param _newAddress The new address to be replaced
    /// @param _nonce Random nonce generated by client
    /// @return The hash of the transaction calculated using by `msg.sender`
    function hashReplaceData(address _oldAddress, address _newAddress, bytes32 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_oldAddress, _newAddress, _nonce));
    }

    /// @notice Triggers when an address is replaced.
    event Replaced(address _originalAddress, address _newAddress);
}